\section{Приближенный алгоритм для задачи о рюкзаке}

\secauthor{\denis}

Напомним сначала классическое, точное решение задачи о рюкзаке методом динамического программирования

\begin{problem*}[0/1-рюкзак]
	Пусть есть $n$ вещей, $i$-тая вещь имеет вес $w_i$ и стоимость $v_i$. Пусть $W$~-- максимальный вес, который выдерживает рюкзак. Найти максимальную стоимость по всем наборам вещей, суммарный вес которого не превышает $W$.
\end{problem*}

\begin{algodescription}{Точное решение за $O\left(n\sum{v_i}=nV\right)$} Динамическое программирование. Пусть $DP(k, X)$~-- минимальный возможный суммарный вес набора стоимостью ровно $X$. Тогда справедливо следующее соотношение:

$$ DP(k, X) = 
\begin{cases}
    0, & k=0\text{ и }X=0, \\
    \infty, & k=0\text{ и }X>0, \\
    DP(k-1, X), & v_k > X, \\
    \min \begin{Bmatrix}
        DP(k-1, X) \\ w_k + DP(k-1, X-v_k)
    \end{Bmatrix}, & \text{иначе}
\end{cases}
$$

Нетрудно придумать <<динамику>>, которая будет использовать массив размера $n \times (V+1)$, и, соответственно, работать за время $O(nV)$. Ответ на задачу~-- максимальное из тех $X$, что $DP(n, X) \leq W$.
\end{algodescription}

Заметим, что это время экспоненциально от размера входных данных.
Нам будет интересно за меньшее время найти приближенное решение.
\begin{definition*}
Оптимизационная задача состоит из отношения $R(x,s)$, задающего возможные решения $s$ для индивидуальной задачи $x$,
и целевой функции $f(x,s)$, задающей ``качество'' решения $s$ для условия $x$ --- неотрицательное вещественное число.

Оптимизационная задача может быть задачей максимизации (найти $s$ такое, что $f(x,s)$ как можно больше)
и задачей минимизации (\ldots поменьше).

Алгоритм $A$ для максимизационной задачи называется $\alpha$-приближенным,
если $\forall x$ он находит такое решение $s^*$, что $f(x,s^*)\ge \alpha\cdot \max_s \{f(x,s)\colon R(x,s)\}$.
Для минимизационной задачи --- наоборот ($\le \alpha \cdot \ldots$).
\end{definition*}

Для заданного $\e$ мы построим $(1-\e)$-приближенный алгоритм для задачи о рюкзаке.
Он будет работать за $O\left(\frac{n^3}{\e}\right)$ времени, а ценность найденного набора будет отличаться от оптимальной на множитель, не превышающий $(1-\e)$.

\begin{algodescription}{Приближенное $(1-\e)$-оптимальное решение за $O\left(\frac{n^3}{\e}\right)$}

Зафиксируем параметр $\e>0$. Заменим все $v_i$ на: $$\hat{v}_i = \left[\frac{n}{\e} \cdot \frac{v_i}{v_{max}}\right]$$ Запустим на новом наборе алгоритм ДП выше.
\end{algodescription}

\begin{theorem*}
    Время работы этого алгоритма есть $O\left(\frac{n^3}{\e}\right)$
\end{theorem*}
\begin{proof}
    $V = \sum v_i \leq n\cdot \frac{n}{\e} = \frac{n^2}{\e}$. Поэтому время $O\left(n \cdot \frac{n^2}{\e}\right) = O\left(\frac{n^3}{\e}\right)$.
\end{proof}

\begin{theorem*}
    Это действительно $(1-\e)$-оптимальный алгоритм.
\end{theorem*}
\begin{proof}
Пусть оптимальное решение исходной задачи~-- набор $S$, его стоимость с точки зрения старой задачи $K^* = \sum\limits_{i\in S} v_i$.

С точки зрения новой задачи сумма этого набора оценивается как:
$$\sum_{i\in S}\hat{v}_i = \sum_{i\in S} \left[\frac{v_i n}{\e v_{max}}\right] \geq \sum_{i\in S} \left(v_i \cdot \frac{n}{\e v_{max}} - 1\right) \geq K^*\frac{n}{\e v_{max}} - n$$

С точки зрения новой задачи набор $S$ необязательно оптимален. То есть, если $\hat{S}$~-- оптимальный с точки зрения новой задачи набор, то имеем $$\sum_{i\in\hat S}\hat{v}_i \geq \sum_{i\in S} \hat{v}_i \geq K^*\frac{n}{\e v_{max}} - n$$

Нужно оценить, насколько стоимости наборов $S$ и $\hat S$ отличаются с точки зрения старой задачи, т.е. сравнить величины $\sum\limits_{i\in S}v_i = K^*$ и $\sum\limits_{i\in\hat S}v_i$. Что же, так как $\hat{v}_i \leq \frac{v_i n}{\e v_{max}}$,

$$\sum_{i\in\hat S}v_i \geq \sum_{i\in\hat S} \hat{v}_i \frac{\e v_{max}}{n} \geq \left(K^*\frac{n}{\e v_{max}} - n\right)\frac{\e v_{max}}{n} = K^* - \e v_{max} \geq K^* - \e K^* = K^*(1-\e)$$

Таким образом, полученное решение может быть дешевле оптимального не сильнее, чем на множитель $(1-\e)$.
\end{proof}
