\section{(19) Алгоритм Борувки для MST. Линейный вероятностный алгоритм для MST. (Осипов Д.)}

\newcommand{\achtung}{\color{red}\textbf{Warning!} Авторское доказательство}

\subsection{Алгоритм Борувки}
Шаг Борувки -- это алгоритм, который сводит задачу поиска миностова у графа к той же задаче, но с меньшим числом вершин у графа (иногда и с меньшим числом ребер). Алгоритм Борувки -- многократное применение шага Борувки. Шаг Борувки базируется на следующей лемме:

\begin{lemma*}[\hypertarget{baselemma}{о безопасных ребрах для алгоритма Борувки}] Для всякой вершины $v \in V$ хотя бы одно смежное с $v$ ребро минимального веса входит в любое минимальное остовное дерево. \end{lemma*}
\begin{proof}[\achtung]
Если все смежные в $v$ ребра имеют одинаковый вес, то доказывать нечего -- вершина $v$ должна быть покрыта хоть каким-то смежным с ней ребром. Пусть теперь среди смежных с $v$ ребер есть ребра веса, строго большего, чем минимальный.

Пусть $T$ -- какой-то минимальный остов. Предположим, что ни одно из ребер, смежных с $v$ и имеющих среди них минимальный вес, не входит в $T$. Пусть $(v, w)$ -- любое такое ребро. Так как $T$ -- остов, то вершина $v$ покрыта более тяжелым ребром из него, пусть $(v, u)$. За $P$ обозначим единственный путь из $u$ в $w$ по дереву $T$. Добавим $(v, w)$ в $T$, тогда $P + (w, v) + (v, u)$ есть цикл в $T\cup\{(v, w)\}$, проходящий через $v$. Удаление ребра $(u, v)$ разрушит этот цикл, и полученное множество ребер $T' = T\smallsetminus \{(v, u)\} \cup \{(v, w)\}$ будет снова остовным деревом. Но вес $T'$ будет строго меньше веса $T$ -- противоречие с минимальностью.
\end{proof}

\begin{algodescription}{Шаг Борувки}
\begin{enumerate}
    \item Для каждой вершины $v \in V$ помечаем смежное с ней ребро минимального веса. Если таких ребер несколько, выбираем ребро с наименьшим номером.
    \item Определим компоненты связности на помеченных ребрах.
    \item Каждую компоненту связности стянем в одну вершину. Некоторые ребра при этом станут петлями или мультиребрами.
    \item Все петли уберем, а в мультиребрах оставим только ребра минимального веса.
\end{enumerate}
\end{algodescription}

Корректность алгоритма Борувки заключается в следующем утверждении:

\begin{theorem*}
	Пусть шаг Борувки получил из графа $G$ граф $G'$. Тогда миностов графа $G$ есть миностов графа $G'$ плюс помеченные в этом шаге Борувки ребра.
\end{theorem*}
Для доказательства воспользуемся:
\begin{lemma*}
	Ребра, отмеченные на шаге Борувки, образуют лес.
\end{lemma*}
\begin{proof}[\achtung ~леммы]

Предположим, что какие-то из отмеченных ребер образовали цикл. Ориентируем ребра этого цикла следующим образом. Пусть в шаге 1 для вершины $v$ было помечено ребро $(v, u)$, тогда ориентируем его как $v\rightarrow u$.

Утверждается, что получившийся орграф есть цикл в ориентированном смысле (а не, например, поток). Действительно, для каждой вершины $v$ в цикле верно $out(v) = 1$ по смыслу алгоритма и $in(v) + out(v) = 2$ по смыслу цикла, значит и $in(v) = 1$.

Итак, пусть имеем цикл $v_1 \rightarrow v_2 \rightarrow \ldots \rightarrow v_k \rightarrow v_1$. Ребро $(v_j, v_{j+1})$, ориентированное как $v_j \rightarrow v_{j+1}$, означает, что оно было выбрано как минимальное среди всех ребер, смежных с $v_j$, откуда имеем для весов $w(v_j, v_{j+1}) \leq w(v_j, v_{j-1})$. Применив это рассуждение для всех вершин в цикле, имеем: $$w(v_1, v_2) \geq w(v_2, v_3) \geq \ldots \geq w(v_{k-1}, v_k) \geq w(v_k, v_1) \geq w(v_1, v_2),$$
откуда следует, что у всех ребер цикла одинаковый вес.

Вспомним, что в случае нескольких смежных ребер с минимальным весом алгоритм выбирает ребро с наименьшим номером (см. шаг 1). Обозначим номер ребра через $\#$. Тогда имеем для всех~$j$ $\#(v_j, v_{j+1}) > \#(v_j, v_{j-1})$, или:
$$\#(v_1, v_2) > \#(v_2, v_3) > \ldots > \#(v_{k-1}, v_k) > \#(v_k, v_1) > \#(v_1, v_2),$$
откуда и получаем противоречие.
\end{proof}

\begin{proof}[\achtung ~теоремы]
Шаг Борувки в графе $G$ построил лес $F$, каждому дереву которого соответствует вершина в графе $G'$. Миностов $T'$ графа $G'$ соединяет все вершины графа $G'$, т.е. все деревья леса $F$ в $G$, поэтому объединение $F$ и $T'$ есть дерево. По \hyperlink{baselemma}{\textit{лемме о безопасных ребрах}} все ребра этого дерева входят в какой-то миностов $G$, ну значит этот миностов и есть $F \cup T'$.
\end{proof}

Теперь несложно получить оценку на время работы.

\begin{lemma*} Время работы шага Борувки есть $O(E+V)$. \end{lemma*}
\begin{proof}

Шаг 1 требует однократного просмотра всех смежных ребер у каждой вершины: $O(E+V)$.

Шаг 2 можно выполнить поиском в глубину, который работает за $O(E+V)$.

Шаг 3 требует переназначения вершин в новые компоненты связности -- $O(V)$ -- и перераспределения всех ребер на новые вершины  -- $O(E)$.

Шаг 4 требует просмотра всех ребер -- $O(E)$.
\end{proof}

В связном графе $V \leq E + 1 = O(E)$, так что верна и оценка $O(E)$.

Заметим, наконец, что всякий шаг Борувки уменьшает число вершин не менее, чем в два раза. Действительно, шаг 1 соединяет каждую вершину с какой-то, значим образуется не более $n/2$ компонент -- вершин в новом графе. Отсюда сразу следует, что применить шаг Борувки до построения полного миностова нужно не более $\log_2 V = O(\log V)$ раз. Общая оценка времени работы алгоритма Борувки есть $O(E\log V)$.

\subsection{Линейный вероятностный алгоритм для MST}

Алгоритм Борувки можно улучшить так, что он будет работать в среднем за $O(E+V)$.

Пусть $F$ -- лес в графе $G$. Обозначим через $w_F(u, v)$ -- вес максимального ребра на единственном пути $u \rightarrow v$ в лесе $F$. Если пути между $u$ и $v$ в $F$ нет, положим $w_F(u,v) = \infty$.

\begin{definition*} Ребро $(u,v)$ назовем \textbf{$F$-тяжелым}, если $w_F(u,v) < w(u,v)$. Иначе назовем ребро \textbf{$F$-легким}.
\end{definition*}

Например, ясно, что всякое ребро $F$ является $F$-легким. Ясно, что ребро $(u,v)$ $F$-тяжелое, если $F$ содержит путь между $u$ и $v$ в $F$, в котором все ребра строго меньшего веса, чем $w(u,v)$.

\begin{lemma*} Пусть $F$ -- любой лес в $G$. Если ребро $(u,v)$ $F$-тяжелое, то оно не лежит в миностове $G$.
\end{lemma*}
\begin{proof}
    Пусть $T$ -- миностов $G$, содержащий $(u,v)$. Без него множество $T\smallsetminus(u,v)$. распадается на две компоненты связности. Из $F$-тяжелости ребра $(u,v)$ существует путь $u\rightarrow v$, ведущий из одной компоненты в другую, все ребра которого строго легче, чем $(u,v)$. Одно из них, скажем, $e$, соединяет две компоненты связности $T\smallsetminus(u,v)$. Его и возьмем, полученное множество $T\smallsetminus(u,v) + e$ будет миностовом строго меньшего веса, чем $T$. Противоречие с минимальностью $T$.
\end{proof}

\begin{definition*}
    Случайный граф $G(p)$ для графа $G$ и числа $0 < p < 1$ строится так: вершины те же, каждое ребро из $G$ входит в $G(p)$ с вероятностью $p$, других ребер нет.
\end{definition*}

\begin{theorem*}
    Пусть $F$ -- минимальный остовный лес случайного графа $G(p)$. Матожидание числа $F$-легких ребер в $G$ не превосходит $\frac{n}{p}$.
\end{theorem*}
\begin{proof}
    $ $

    \textbf{NB. } Сокращение: $F$-легкое = $F$-легкое для $G$.

    Упорядочим все ребра $G$ в порядке возрастания весов: $e_1, e_2, \ldots, e_m$. Будем строить граф $G(p)$, рассматривая ребра именно в этом порядке. Минимальный остовный лес $F$ мы будем строить одновременно с $G(p)$ следующим образом. Если $e_i$ взято в $G(p)$ и если $e_i$ соединило две разные компоненты $F$ на тот момент, то мы берем $e_i$ в $F$.

    Ребро $e_i = (u,v)$ $F$-легкое в момент рассмотрения $\iff$ в момент рассмотрения в $F$ нет пути $u \rightarrow v$, содержащего ребро более тяжелое, чем $e_i$. Из-за порядка рассмотрения, если между $u$ и $v$ уже был путь в $F$, то из-за него ребро $e_i$ автоматически становится $F$-тяжелым, потому что все ребра этого пути были рассмотрены раньше $e_i$. Стало быть, ребро $e_i$ $F$-легкое в момент рассмотрения $\iff$ оно соединяет две разные компоненты в $F$.

    Однако добавление ребер в $F$ после $e_i$ никак не влияет на $F$-легкость ребра $e_i$ (снова в силу порядка рассмотрения ребер). То есть, ребро $e_i$ $F$-легкое в конце построения $G(p)$ $\iff$ ребро $e_i$ $F$-легкое в момент рассмотрения ребра $e_i$.

    Резюмируя сказанное выше, ребро $e_i$ $F$-легкое (в конце построения $G(p)$) $\iff$ оно когда-то соединило (если попало в $G(p)$) или могло соединить (если не попало в $G(p)$) две разные компоненты $F$ в процессе построения $F$.

    Определим $k$-тую фазу построения $F$ как начинающуюся в момент, когда в $F$ находится $k-1$ ребро и заканчивающуюся, когда в $F$ добавляется $k$-тое по счету ребро. Всякое $F$-легкое ребро, рассматриваемое в этой фазе, с вероятностью $p$ попадает в $G(p)$ и, следовательно, в $F$. Фаза $k$ заканчивается добавлением в $G(p)$ (и $F$) любого $F$-легкого ребра. Стало быть, случайная величина $e_k$, определенная как число рассмотренных $F$-легких ребер за фазу $k$, имеет распределение: $$\mathbb P(e_k = l) \leq  p(1-p)^{l-1}$$.

    Это геометрическое распределение, $\mathbb E e_k \leq \frac{1}{p}$.

    Пусть лес $F$ в конце алгоритма имеет $s < n$ ребер. Сумма $e_1 + ... + e_{s-1}$ есть случайная величина, означающая число рассмотренных $F$-легких ребер за весь процесс построения $G(p)$, то есть просто число всех $F$-легких ребер в $G$. Ясно, что ее матожидание не превосходит $\frac{n}{p}$.

\end{proof}

На этой теореме базируется следующая модификация алгоритма Борувки, которая из графа $G_1$ с $n$ вершинами и $m$ ребрами строит минимальный остовный лес (ибо граф может быть несвязен).

\begin{algodescription}{Линейный вероятностный Борувка}
\begin{enumerate}
    \item Применим к $G_1$ 3 шага Борувки, пусть $G_2$~-- полученный граф с $\leq \frac{n}{2}$~-- вершин, $S$~-- множество всех отмеченных ребер.
    \item Построим случайный граф $G_2\left(\frac{1}{2}\right)$. В нем будет $\leq\frac{n}{8}$ вершин, а матожидание ребер будет $\leq\frac{m}{2}$.
    \item Рекурсивно построим миностов $F$ графа $G_2\left(\frac{1}{2}\right)$.
    \item Найдем все $F$-тяжелые ребра графа $G_2$. Выкинем их из $G_2$, получится граф $G_3$. В нем не более $\frac{m}{4}$ ребер (применяем предыдущую теорему для $p=\frac{1}{2}$ и числа ребер $\frac{n}{2})$.
    \item Рекурсивно построим миностов $F_3$ графа $G_3$. Выдадим ответ: миностов есть $S \cup F_3$
\end{enumerate}
\end{algodescription}

\begin{theorem*}
    Матожидание времени работы этого алгоритма $O(n+m)$.
\end{theorem*}
\begin{proof}
    Пусть $T(n, m)$~-- максимум по всем графам на $n$ вершинах и $m$ ребрах матожидания времени работы этого алгоритма.
    По шагам:
    \begin{enumerate}
        \item $O(n+m)$
        \item $O(n+m)$
        \item $T\left(\frac{n}{8}, \frac{m}{2}\right)$
        \item $O(n+m)$ (верим)
        \item $T(\frac{n}{8}, \frac{n}{4})$
    \end{enumerate}

    $$T(n, m) = T\left(\frac{n}{8}, \frac{m}{2}\right) + T\left(\frac{n}{8}, \frac{n}{4}\right) + O(n+m)$$

    Несложная индукция: $T(n, m) = O(n+m)$.
\end{proof}
