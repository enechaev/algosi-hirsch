\section{Рандомизированный QuickSort (Осипов Д.)}

В этом параграфе мы строго докажем, что среднее время (матожидание времени) работы рандомизированного Quicksort есть $O(n\log n)$.

Приведем его реализацию (Cormen). Сортировка всего массива вызывается \texttt{Quicksort(A, 1, len(A)}.

\LinesNumbered
\begin{algorithm}[H]
\caption{Нижний текст}
\SetKwFunction{partition}{Partition}
\partition{$A, p, r$}:\\
$i$ = random $\in [p, r]$\\
$A[r] \leftrightarrow A[i]$\\
$x$ = $A[r]$ \\
$i$ = $p-1$ \\
\For{$j$ = $p...r-1$}{
    \If{$A[j] \leq x$}{
        $i$++\\
        $A[i] \leftrightarrow A[j]$
    }
}
$A[i+1] \leftrightarrow A[r]$\\
\KwRet{$i+1$}

$ $\\

\SetKwFunction{quicksort}{Quicksort}
\quicksort{$A, p, r$}: \\
\If {$p<r$}{
    $q$ = \partition{$A, p, r$} \\
    \quicksort{$A, p, q-1$} \\
    \quicksort{$A, q+1, r$}
}
\end{algorithm}

Напомним, как работает процедура \texttt{Partition}. Она обрабатывает отрезок $[p..r]$ массива $A$ следующим образом.  В строках 2-4 случайно выбирается \textit{опорный элемент}, который перемещается в конец отрезка и запоминается в $x$. В строках 5-11 элементы $[p...r-1]$ меняются таким образом, что все элементы $\leq x$ расположены слева, а все элементы $> x$ справа. Строка 12 располагает $x$ между этими частями (немного меняя правую часть). Таким образом, отрезок $A[p..r]$ разбивается на три части: сначала идут элементы $\leq x$, потом сам $x$, потом $> x$. Строка 13 возвращает позицию $x$.

\underline{Итак, считаем среднее время}. За $X$ обозначим случайную величину -- общее число сравнений, произведенных на строке 7, за все время выполнения \texttt{Quicksort(A, 1, len(A))}. Из строк 18-19 видно, что каждый вызов \texttt{Quicksort} <<убирает>> из работы один элемент массива, поэтому всего вызовов \texttt{Partition} не более $n$. Каждый вызов \texttt{Partition} совершает $O(1)$ действий плюс какое-то количество сравнений, так что суммарное время работы \texttt{Quicksort(A, 1, len(A))} есть $O(n+X)$.

Нам нужно вычислить матожидание общего числа сравнений $\mathbb E X$. Переименуем элементы $A$ как $z_1 \leq ... \leq z_n$.

Заметим, что любая пара элементов сравнивается не более одного раза. Действительно, при любом сравнении, как видно из строки 7, один из двух сравниваемых элементов -- опорный, и после окончания цикла (строка 6) этот опорный элемент <<выпадает>> из работы и более ни с чем не сравнивается. Так что введем случайную величину $X_{ij} = [z_i, z_j \text{ когда-то сравнивались}]$. Ясно, что тогда:

$$\mathbb E X = \mathbb E \sum_{i=1}^{n-1} \sum_{j=i+1}^n X_{ij} = \sum_{i=1}^{n-1} \sum_{j=i+1}^n \mathbb E X_{ij} = \sum_{i=1}^{n-1} \sum_{j=i+1}^n \mathbb P[z_i, z_j \text{ когда-то сравнивались}]$$.

Осталось подсчитать $\mathbb P[z_i, z_j\text{ когда-то сравнивались}]$. Нужно выяснить, в каком случае $z_i$ и $z_j$ сравнятся, а в каких нет.

Для примера рассмотрим массив, содержащий в каком-то порядке числа $\{1,2,3,4,5,6,7,8,9,10\}$. Пусть первым опорным элементом стала 7. Во-первых, это означает, что на данном этапе 7 сравнится со всеми остальными числами, а далее <<выпадет>> и ни с чем сравниваться не будет. Во-вторых, множество разбивается на две части $\{1,2,3,4,5,6\}$ и $\{8,9,10\}$ в том смысле, что все дальнейшие сравнения будут происходить \textbf{только} внутри этих частей. Например, 2 и 9 точно не сравнятся, а 2 и 4 могут сравниться (если не попадут в разные части на какой-нибудь из следующих итераций). 

В общем случае всё обстоит так: если какой-то элемент $x$ ($z_i \leq x \leq z_j$) был опорным до того, как опорными стали $z_i$ и $z_j$, то $z_i$ и $z_j$ не сравнятся. И наоборот -- если ни один из элементов $z_i, z_{i+1}..., z_j$ не стал опорным до того, как опорным стал $z_i$ или $z_j$, то $z_i$ и $z_j$ сравнятся.

Итак, можно видеть, что $z_i$ и $z_j$ сравнятся тогда и только тогда, когда среди элементов $z_i, z_{i+1}, ..., z_j$ раньше всех опорным элементом станет либо $z_i$, либо $z_j$. Вероятность этого равна $\frac{2}{j-i+1}$.

Имеем: $$\mathbb E X = \sum_{i=1}^{n-1} \sum_{j=i+1}^n \frac{2}{j-i+1}$$

Замена переменных во внутренней сумме $k = j-i$ дает:

$$ = \sum_{i=1}^{n-1} \sum_{k=1}^{n-i} \frac{2}{k+1} < \sum_{i=1}^n \sum_{k=1}^n \frac{2}{k} = \sum_{i=1}^n O(\log n) = O(n \log n)$$

Таким образом, матожидание времени работы \texttt{Quicksort} есть $O(n+n\log n) = O(n\log n)$. $\blacksquare$