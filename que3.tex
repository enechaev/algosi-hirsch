\section{Параллельные алгоритмы~-- iii}

\secauthor{\denis, \egor}

\subsection{Параллельное вычисление всех расстояний до конца списка}
\begin{problem*}
Дан список $a_1, \ldots, a_n$  в следующем формате. Про каждый элемент $a_i$ известно, какой элемент за ним следует. Обозначим его номер за \texttt{next[i]}. Если за элементом ничего не следует, считаем \texttt{next[i] == nil}. Предположим, что указатели \texttt{next[i]} действительно образуют список. Найти расстояние до конца списка для каждого элемента.
\end{problem*}
\begin{algodescription}{Решение за $O(\log n)$}

Каждому элементу $a_i$ сопоставим процессор $p_i$. Заведем массив \texttt{d[1..n]}, проинициализируем его следующим образом. На первом параллельном шаге для концевого \texttt{i} (\texttt{next[i] == nil}) положим \texttt{d[i] = 0}, для всех остальных положим \texttt{d[i] = 1}. В дальнейшем указатели будут изменяться (таким образом, структура списка будет нарушаться), и тогда \texttt{d[i]} будет означать расстояние между $a_\texttt{i}$ и $a_{\texttt{next[i]}}$ \underline{в исходном списке}.

Далее на каждом параллельном шаге происходит пересчет расстояний. Именно, каждый процессор $\mathtt i$, для которого \texttt{next[i]} $\neq$ \texttt{nil}, делает следующее (порядок важен!): запоминает \texttt{d[next[i]]}, затем увеличивает \texttt{d[i]} на запомненное значение. После этого (снова порядок важен!) процессор \texttt{i} запоминает \texttt{next[next[i]]}, затем присваивает это значение к \texttt{next[i]}. Алгоритм останавливается, когда все \texttt{next[i] == nil}.

Алгоритм корректно находит ответ. Действительно, только что описанный цикл сохраняет инвариант <<\texttt{d[i]}~-- расстояние между $a_\texttt{i}$ и $a_\texttt{next[i]}$ в исходном списке>>, а в конце алгоритма все \texttt{next[i] == nil}

Время работы алгоритма $O(\log n)$. Это следует из того, что начальная инициализация и каждая итерация цикла проходят за $O(1)$ времени, а сам цикл выполняется $\log n$ раз: за итерацию цикла $d_i$ либо удваивается, либо ему присваивается \texttt{nil}.
\end{algodescription}

\subsection{Параллельное вычисление всех глубин дерева}
\begin{problem*}
	Дано подвешенное неориентированное дерево на $n$ вершинах, занумерованных \\ $\{0,\ldots,n-1\}$ в следующем формате. Имеются три массива $left[0\ldots n-1], right[0\ldots n-1], parent[0\ldots n-1]$, для каждого $i$ $left[i], right[i] \text{ и } parent[i]$ суть номера левого потомка, правого потомка, родителя вершины $i$ (при отсутствии какого-то из параметров присвоено \texttt{nil}). Предположим, что эти массивы действительно задают дерево. Вычислить глубины всех вершин относительно корня.
\end{problem*}
\begin{algodescription}{Решение за $O(\log n)$} Сопоставим каждой вершине $i$ три процессора $A_i, B_i, C_i$\footnote{Я, честно говоря, так и не понял, по какой причине они называются процессорами. Как мне кажется, намного легче интерпретировать это как просто 3 числа, сопоставленные каждому узлу дерева.}. Перестроим дерево в ориентированный граф, вершины которого будут этими процессорами. Именно, проведем ребро:
\begin{itemize}
	\item $A_i \rightarrow A_{left[i]}$, либо $A_i \rightarrow B_i$, если $left[i] == \texttt{nil}$;
	\item $B_i \rightarrow A_{right[i]}$, либо $B_i \rightarrow C_i$, если $right[i] == \texttt{nil}$;
	\item $C_i \rightarrow \ldots$
	\begin{itemize}
		\item $\ldots B_{parent[i]}$, если $i$~-- левый потомок,
		\item $\ldots C_{parent[i]}$, если $i$~-- правый потомок,
		\item $\ldots \texttt{nil}$, если $parent[i] == \texttt{nil}$ ($i$~-- корень) (можно, наверное, считать, что у корневой вершины нет процессора $C$).
	\end{itemize}
\end{itemize}

Можно проверить\footnote{Например, вспомнить критерий полуэйлеровости: для всех вершин $v$, кроме двух, $in(v) = out(v)$, а для особых двух вершин $in(v_1) = out(v_1) + 1$ и $in(v_2) = out(v_2) - 1$.}, что у этого графа существует эйлеров обход, начинающийся в $A$ корня и заканчивающийся в $C$ корня.

Поместим теперь\footnote{Вот видите, это просто числа а никакие не процессоры. Кто это название вообще придумал?} в процессоры $A_i$ число $1$, в $B_i$ число $0$, в $C_i$ число $-1$. эйлеров обход графа превратился в последовательность чисел, у которой мы умеем параллельно вычислять частичные суммы (мы учились это делать в~\ref{parallel_sums}).
\end{algodescription}

\begin{theorem*}
	Частичная сумма, вычисленная до $C_i$~--- это глубина вершины $i$.
\end{theorem*}
\begin{proof}
	Заметим из устройства нашего дерева, что процессор $C_i$ встречается всегда перед процессором $A_i$, $A_i$ потомка встречается позже $A_j$ предка, а с $C_i,C_j$ наоборот. Процессор $A_i$ добавляет $1$, процессор $B_i$ добавляет $0$, процессор $C_i$ добавляет $-1$, поэтому вклад в сумму от посещения поддеревьев нулевой. До $C_i$ $C$-процессоры могут встречаться только в поддеревьях предков вершины $i$ и поддеревьях самой вершины $i$, но они не вносят вклад в сумму. Поэтому в сумму добавляют только $A$-вершины предков (а их на 1 больше, чем глубина вершины), а отнимает только $C_i$, то есть вся сумма~-- это ровно глубина.
\end{proof}