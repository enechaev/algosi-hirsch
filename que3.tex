\section{(3) Параллельные алгоритмы~-- iii (Осипов Д., \groth)}
\newcommand{\nxt}[1] {\mathtt{next[#1]}}
\newcommand{\nil} {\mathtt{nil}}
\subsection{(В РАЗРАБОТКЕ) Параллельное вычисление всех расстояний до конца списка}
\begin{problem*}
Дан список $a_1, \ldots, a_n$  в следующем формате. Про каждый элемент $a_i$ известно, какой элемент за ним следует. Обозначим его номер за $\nxt{i}$. Если за элементом ничего не следует, считаем $\nxt{i} == \nil$. Предположим, что указатели $\nxt{i}$ действительно образуют список. Найти расстояние до конца списка для каждого элемента.
\end{problem*}
У нее есть решение за $O(\log n)$.

Каждому элементу $a_i$ сопоставим процессор $p_i$. Заведем массив $d_i$, проинициализируем его следующим образом. На первом параллельном шаге для концевого $i$ ($next[i]==\nil$) положим $d_i = 0$, для всех остальных положим $d_i = 1$. В дальнейшем указатели будут изменяться (таким образом, структура списка будет нарушаться), и тогда $d_i$ будет означать расстояние между $a_i$ и $a_{next[i]}$ \underline{в исходном списке}.

Далее на каждом параллельном шаге происходит пересчет расстояний. Именно, каждый процессор $\mathtt i$, для которого $\nxt{i} \neq \nil$, делает следующее (порядок важен!): запоминает $d[\nxt{i}]$, затем увеличивает $d[i]$ на запомненное значение. После этого (снова порядок важен!) процессор $\mathtt i$ запоминает $\nxt{\nxt{i}}$, затем присваивает это значение к $\nxt{i}$. Алгоритм останавливается, когда все $\nxt{i} == \nil$.

Алгоритм корректно находит ответ. Действительно, только что описанный цикл сохраняет инвариант <<$d_i$~-- расстояние между $a_i$ и $a_{next[i]}$ в исходном списке>>, а в конце алгоритма все $next[i] == \nil$.

Про корректность обращений к памяти читайте Cormen'а, я нифига не понимаю, наверное это и не нужно?????

Время работы алгоритма $O(\log n)$. Это следует из того, что начальная инициализация и каждая итерация цикла проходят за $O(1)$ времени, а сам цикл выполняется $\log n$ раз: все значения, для которых ?????.\qed

\subsection{Параллельное вычисление всех глубин дерева}
\begin{problem*}
	Дано подвешенное неориентированное дерево на $n$ вершинах, занумерованных $\{0,\ldots,n-1\}$ в следующем формате. Имеются три массива $left[0\ldots n-1], right[0\ldots n-1], parent[0\ldots n-1]$, для каждого $i$ $left[i], right[i] \text{ и } parent[i]$ суть номера левого потомка, правого потомка, родителя вершины $i$ (при отсутствии какого-то из параметров присвоено $\nil$). Предположим, что эти массивы действительно задают дерево. Вычислить глубины всех вершин относительно корня.
\end{problem*}
\statement{Решение за $O(\log n)$.}{} Сопоставим каждой вершине $i$ три процессора $A_i, B_i, C_i$\footnote{Я, честно говоря, так и не понял, по какой причине они называются процессорами. Как мне кажется, намного легче интерпретировать это как просто 3 числа, сопоставленные каждому узлу дерева.}. Перестроим дерево в ориентированный граф, вершины которого будут этими процессорами. Именно, проведем ребро:
\begin{itemize}
	\item $A_i \rightarrow A_{left[i]}$, либо $A_i \rightarrow B_i$, если $left[i] == \nil$;
	\item $B_i \rightarrow A_{right[i]}$, либо $B_i \rightarrow C_i$, если $right[i] == \nil$;
	\item $C_i \rightarrow \ldots$
	\begin{itemize}
		\item $\ldots B_{parent[i]}$, если $i$~-- левый потомок,
		\item $\ldots C_{parent[i]}$, если $i$~-- правый потомок,
		\item $\ldots \nil$, если $parent[i] == \nil$ ($i$~-- корень) (можно, наверное, считать, что у корневой вершины нет процессора $C$).
	\end{itemize}
\end{itemize}

Можно проверить\footnote{Например, вспомнить критерий полуэйлеровости: для всех вершин $v$, кроме двух, $in(v) = out(v)$, а для особых двух вершин $in(v_1) = out(v_1) + 1$ и $in(v_2) = out(v_2) - 1$.}, что у этого графа существует эйлеров обход, начинающийся в $A$ корня и заканчивающийся в $C$ корня.

Поместим теперь\footnote{Вот видите, это просто числа а никакие не процессоры. Кто это название вообще придумал?} в процессоры $A_i$ число $1$, в $B_i$ число $0$, в $C_i$ число $-1$. эйлеров обход графа превратился в последовательность чисел, у которой мы умеем параллельно вычислять частичные суммы (мы учились это делать в~\ref{parallel_sums}).
\begin{theorem*}
	Частичная сумма, вычисленная до $C_i$~--- это глубина вершины $i$.
\end{theorem*}
\begin{proof}
	Заметим из устройства нашего дерева, что процессор $C_i$ встречается всегда перед процессором $A_i$, $A_i$ потомка встречается позже $A_j$ предка, а с $C_i,C_j$ наоборот. Процессор $A_i$ добавляет $1$, процессор $B_i$ добавляет $0$, процессор $C_i$ добавляет $-1$, поэтому вклад в сумму от посещения поддеревьев нулевой. До $C_i$ $C$-процессоры могут встречаться только в поддеревьях предков вершины $i$ и поддеревьях самой вершины $i$, но они не вносят вклад в сумму. Поэтому в сумму добавляют только $A$-вершины предков (а их на 1 больше, чем глубина вершины), а отнимает только $C_i$, то есть вся сумма~-- это ровно глубина.
\end{proof}